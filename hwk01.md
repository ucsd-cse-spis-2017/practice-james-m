1. Chapter 1 discusses declarative vs. imperative knowledge. How would you explain the difference?
Imperatice knowledge is knowing how to do something, instead of just knowing something. That 'how to do' phrase is the key element.

2. How would you explain the difference between fixed-program and stored-program computers?

Fixed program computers can only perform a single program, while stored-program computers store different programs and call them up at will.
A simple calculator is an example of a fix-program device, since it can only perform one program.

3. In the context of describing the Church-Turing thesis, Guttag mentions that some functions are “not computable”,
and gives an example. What is this example of an “uncomputable function”?

The halting problem is an example of a function that is not computable because a value cannot return true if it runs forever.

4. Computer Science professors and students tend to argue a lot about whether one programming language is “better” than another. 
What is the signficance of the notion of Turing Completeness to this kind of discussion?

All languages are able to perform the same computations, even if one is more/less wordy or easier/harder to understand.

5. So far, we’ve provided some questions to guide your reading. However, in many university level courses,
you’ll need to develop the skill of deciding for yourself what the important parts are in a reading passage.
Please read the rest of the material on pages 4, 5 and 6 and provide your own summary of what you think the most 
important concepts on these pages are, confining that summary to the space provided below. For each important concept,
also come up with a practice quiz/exam question you might pose to a friend if you were helping them study.

The syntax of a computer language is very important in understanding the types and effects of the errors that can be produced. Similar to
the english language, computer language must be formed into the appropriate sytax, which is the word formation order, in order to make sense
to the compiler or the interpreter.
